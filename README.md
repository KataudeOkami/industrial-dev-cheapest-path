# industrial-dev-cheapest-path

## Решение задачи по нахождению минимальной стоимости пути от вершины пирамиды до ее основания.
Мною предлагается решение с использованием подхода динамического программирования, когда от вершины к основанию вычисляются все оптимальные решения за один полный проход пирамиды.
При решении будем полагать, что в каждой ячейке пирамиды находится значение, представляющее собой "стоимость" посещения данной ячейки. В таком случае цель задачи - нахождение минимальной стоимости прохождения от вершины до основания пирамиды.

Опишем логику решения:
Представим, что нам для каждой ячейки нужно вычислить минимальную стоимость попадания в нее по любому из возможных (естественно, следуя правилам, оговоренным в задании) путей. В произвольно взятую ячейку мы попадаем либо из левой верхней (i-1-ый элемент строки выше), либо из правой верхней (i-ый элемент строки выше) ячейки. Предположим, что обе верхние (относительно текущей) ячейки уже содержат в себе минимальные стоимости попадания в них из всех возможных траекторий. В таком случае минимальная стоимость попадания в произвольно выбранную ячейку складывается из: а) стоимости попадания в саму ячейку (значение в ней), и б) минимальной из двух стоимостей попадания в верхние ячейки:
```python
triangle[i][j] = triangle[i][j] + min(triangle[i - 1][j - 1], triangle[i - 1][j])
```

Это и есть рекуррентная зависимость, которую нужно использовать при решении нашей задачи с использованием динамического программирования.

При этом важно отметить, что не для всех ячеек данная формула будет справедлива, ведь она требует наличия как левого верхнего элемента, так и правого верхнего. Это, к примеру, не выполняется для "сторон" треугольника (все 1-е и последние элементы каждой строки), и для элементов 1-ой и 2-ой строк.

Итак, после вычисления минимальной стоимости для каждой ячейки, нужно лишь выбрать минимальное значение в основании пирамиды (последняя строка). Эта стоимость и будет являться конечным ответом на задачу.

Говоря об алгоритмической сложности, явно видно, что для полного решения необходим 1 полный обход всех элементов пирамиды. Если взять высоту пирамиды за N, то алгоритмическая сложность обхода по времени будет равна O(N^2), что и требовалось в решении. Если мы говорим о сложности по памяти, то есть два варианта: либо менять пирамиду "на месте", либо создать полную копию пирамиды и изменять уже ее, дабы не изменять исходную. В первом случае будет сложность O(1), так как никакой дополнительной памяти не выделяется, во втором же - O(N^2), ввиду создания копии исходной пирамиды.


## Не удавшиеся задачи
К сожалению, мне не удалось осилить первую задачу (про отрезки и точки), попросту не приходило никаких четких мыслей, так как я пытался опираться на количество пересечений отрезков при рассмотрении нескольких отрезков. Вместо этого нужно было отсортировать отрезки по какому-либо краю и ставить точки на другом краю. Эти точки мы запоминаем и при "добавлении" нового отрезка проверяем, покрывает ли эта точка отрезок, если нет - ставим новую точку. Таким образом мы соберем минимально необходимое количество точек, так еще и запомним их расположение.
С остальными задачами проблем не было, разве что формулировка второй довольно сильно "плавает", стоит добавить примеров и расписать ее более подробно.


